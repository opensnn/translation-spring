# 46、测试

Spring Boot 提供了许多实用程序和注解来帮助你测试应用程序。测试支持由两个模块提供 ：spring-boot-test 包含核心项目，spring-boot-test-autoconfigure 支持测试的自动配置。

大多数开发者使用 spring-boot-starter-test “Starter”，它导入了 Spring Boot 测试模块以及 JUnit 、 AssertJ 、 Hamcrest 和其他一些有用的库。

## 46.1、Test Scope Dependencies

spring-boot-starter-test “Starter”（在测试范围内）包含以下提供的库：

（1）[JUnit 4](https://junit.org/)：Java 应用程序单元测试的事实标准。

（2）[Spring Test](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/testing.html#integration-testing) 和 Spring Boot Test：Spring Boot 应用程序的实用程序（Utilities）和集成测试支持。

（3）[AssertJ](https://joel-costigliola.github.io/assertj/)：一个流畅的断言库。

（4）[Hamcrest](https://github.com/hamcrest/JavaHamcrest)：匹配对象库（也称为约束或谓词）。

（5）[Mockito](https://mockito.github.io/)：一个 Java 模拟框架。

（6）[JSONassert](https://github.com/skyscreamer/JSONassert)：JSON 的断言库。

（7）[JsonPath](https://github.com/jayway/JsonPath)：JSON 的 XPath。

我们通常发现这些公共库在编写测试时很有用。如果这些库不适合你的需要，你可以添加自己的额外测试依赖项。

## 46.2、测试 Spring 应用程序

依赖注入的一个主要优点是它应该使你的代码更容易进行单元测试。你甚至可以使用 new 运算符实例化对象，而不涉及 Spring。你还可以使用模拟对象而不是真正的依赖项。

通常，你需要超越单元测试，开始集成测试（使用 Spring ApplicationContext）。能够在不需要部署应用程序或连接到其他基础设施的情况下执行集成测试是非常有用的。

Spring Framework 包含了一个专门的集成测试模块。你可以直接声明一个 org.springframework:spring-test 依赖项，或者使用 spring-boot-starter-test “Starter”以传递方式将其拉入。

如果你以前没有使用过 spring-test 模块，你应该从阅读 Spring Framework 参考文档的[相关部分](https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/testing.html#testing)开始。

## 46.3、测试 Spring Boot 应用程序

Spring Boot 应用程序是 Spring ApplicationContext，因此除了通常使用普通的 Spring 上下文所做的事情之外，不必做任何特别的事情来测试它。

注释：默认情况下，只有在使用 SpringApplication 创建 Spring Boot 时，后者的外部属性、日志记录和其他功能才会安装在上下文中。

Spring Boot 提供了一个 @SpringBootTest 注解，当你需要 Spring Boot 功能时，它可以作为标准 spring-test @ContextConfiguration 注解的替代。该注解的工作方式是通过 SpringApplication 创建测试中使用的 ApplicationContext。除了 @SpringBootTest 之外，还提供了许多其他注解来测试应用程序更具体的切片。

提示：如果你正在使用 JUnit 4，不要忘记在你的测试中添加 @RunWith(sprint grunner.class)，否则注解将被忽略。如果你使用的是 JUnit 5，则无需添加等效的 @ExtendWith(SpringExtension.class) 作为 @SpringBootTest，其他 @… 测试注解已经用它注解了。

默认情况下，@SpringBootTest 不会启动服务器。你可以使用 @SpringBootTest 的 webEnvironment 属性来进一步优化测试的运行方式：

（1）MOCK（默认）：加载 web ApplicationContext 并提供模拟 web 环境。使用此注解时，嵌入式服务器不会启动。如果你的类路径上没有可用的 web 环境，则此模式将透明地返回到创建常规的非 web ApplicationContext。它可以与 @AutoConfigureMockMvc 或 @AutoConfigureWebTestClient 结合使用，用于 web 应用程序的基于模拟的测试。

（2）RANDOM_PORT：加载 WebServerApplicationContext 并提供一个真实的 web 环境。嵌入式服务器在随机端口上启动和监听。

（3）DEFINED_PORT：加载 WebServerApplicationContext 并提供一个真实的 web 环境。嵌入式服务器在一个定义的端口（来自 application.properties）或默认端口 8080 上启动和侦听。

（4）NONE：通过使用 SpringApplication 加载 ApplicationContext，但不提供任何 web 环境（mock 或其他）。

注释：如果你的测试是 @Transaction，则默认情况下，它会在每个测试方法结束时回滚事务。然而，由于对 RANDOM_PORT 或 DEFINED_PORT 使用这种安排隐式地提供了一个真正的 servlet 环境，所以 HTTP 客户端和服务器在单独的线程中运行，从而运行在单独的事务中。在这种情况下，服务器上启动的任何事务都不会回滚。

注释：如果你的应用程序为管理服务器使用不同的端口，那么使用 webEnvironment = WebEnvironment.RANDOM_PORT 的 @SpringBootTest 也将在一个单独的随机端口上启动管理服务器。

### 46.3.1、检测 Web 应用程序类型

如果 Spring MVC 可用，则配置一个常规的基于 MVC 的应用程序上下文。如果你只有 Spring WebFlux，我们将检测它并配置一个基于 WebFlux 的应用程序上下文。

如果两者都存在，则 Spring MVC 优先。如果要在这个场景中测试反应式 web 应用程序，则必须设置 spring.main.web-application-type 属性：

```
@RunWith(SpringRunner.class)
@SpringBootTest(properties = "spring.main.web-application-type=reactive")
public class MyWebFluxTests { ... }
```

### 46.3.2、检测测试配置

如果你熟悉 Spring Test Framework，那么可能习惯于使用 @ContextConfiguration(classes=…) 来指定要加载哪个 Spring @Configuration。或者，你可能经常在测试中使用嵌套的 @Configuration 类。

在测试 Spring Boot 应用程序时，通常不需要这样做。当你没有明确定义主配置时，Spring Boot 的 @*Test 注解会自动搜索主配置。

搜索算法从包含测试的包开始工作，直到找到一个用 @SpringBootApplication 或 @SpringBootConfiguration 注解的类。只要你以合理的方式构建代码，你的主要配置通常会被找到。

注解：

如果你使用测试注释来测试应用程序的更具体的切片，则应避免在主方法的应用程序类上添加特定于特定区域的配置设置。

@SpringBootApplication 的底层组件扫描配置定义了用于确保切片按预期工作的排除过滤器。如果在基于注解 @SpringBootApplication 的类上使用显式的 @ComponentScan 指令，请注意这些过滤器将被禁用。如果使用切片，则应重新定义它们。

如果要自定义主配置，可以使用嵌套的 @TestConfiguration 类。与嵌套的 @Configuration 类（将用于替代应用程序的主配置）不同，嵌套的 @TestConfiguration 类是在应用程序的主配置之外使用的。

注释：Spring 的测试框架在测试之间缓存应用程序上下文。因此，只要你的测试共享相同的配置（无论如何发现），加载上下文的潜在耗时过程只会发生一次。

### 46.3.3、排除测试配置

如果你的应用程序使用组件扫描（例如，如果你使用 @SpringBootApplication 或 @ComponentScan），你可能会发现仅为特定测试创建的顶级配置类会意外地在任何地方出现。

如前所述，@TestConfiguration 可用于测试的内部类，以自定义主配置。当放置在顶级类上时，@TestConfiguration 表示 src/test/java 中的类不应该通过扫描来获取。然后，可以在需要时显式导入该类，如下例所示：

```
@RunWith(SpringRunner.class)
@SpringBootTest
@Import(MyTestsConfiguration.class)
public class MyTests {

    @Test
    public void exampleTest() {
        ...
    }

}
```

注释：如果你直接使用 @ComponentScan (也就是说，不是通过 @SpringBootApplication)，你需要用它注册 TypeExcludeFilter。有关详细信息，请参见 [Javadoc](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/context/TypeExcludeFilter.html)。

### 46.3.4、使用模拟环境进行测试

默认情况下，@SpringBootTest 不启动服务器。如果你有要针对此模拟环境进行测试的 web 端点，则可以另外配置 MockMvc，如以下示例所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class MockMvcExampleTests {

    @Autowired
    private MockMvc mvc;

    @Test
    public void exampleTest() throws Exception {
        this.mvc.perform(get("/")).andExpect(status().isOk()).andExpect(content().string("Hello World"));
    }

}
```

提示：如果你只想关注 web 层而不启动完整的 ApplicationContext，请考虑使用 @WebMvcTest。

或者，你可以配置 WebTestClient，如下面示例所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.reactive.server.WebTestClient;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWebTestClient
public class MockWebTestClientExampleTests {

    @Autowired
    private WebTestClient webClient;

    @Test
    public void exampleTest() {
        this.webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class)
                .isEqualTo("Hello World");
    }

}
```

### 46.3.5、使用正在运行的服务器进行测试

如果你需要启动完全运行的服务器，我们建议你使用随机端口。如果使用 @SpringBootTest (webEnvironment=WebEnvironment.RANDOM_PORT)，则每次测试运行时都会随机选择一个可用端口。

@LocalServerPort 注解可用于将实际使用的端口注入测试。为了方便起见，需要对启动的服务器进行 REST 调用的测试还可以 @Autowire 一个 WebTestClient，它解析到正在运行的服务器的相关链接，并附带用于验证响应的专用 API，如下面示例所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.reactive.server.WebTestClient;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class RandomPortWebTestClientExampleTests {

    @Autowired
    private WebTestClient webClient;

    @Test
    public void exampleTest() {
        this.webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class)
                .isEqualTo("Hello World");
    }

}
```

此设置需要类路径上的 spring-webflux。如果你不能或不想添加 webflux，Spring Boot 还提供了一个 TestRestTemplate 工具：

```
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.test.context.junit4.SpringRunner;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class RandomPortTestRestTemplateExampleTests {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void exampleTest() {
        String body = this.restTemplate.getForObject("/", String.class);
        assertThat(body).isEqualTo("Hello World");
    }

}
```

### 46.3.6、使用 JMX

由于测试上下文框架缓存上下文，因此默认情况下禁用 JMX 以防止相同的组件在同一域上注册。如果此类测试需要访问 MBeanServer，请考虑将其标记为脏（dirty）：

```
@RunWith(SpringRunner.class)
@SpringBootTest(properties = "spring.jmx.enabled=true")
@DirtiesContext
public class SampleJmxTests {

    @Autowired
    private MBeanServer mBeanServer;

    @Test
    public void exampleTest() {
        // ...
    }

}
```

### 46.3.7、模拟和监视 Beans

运行测试时，有时需要在应用程序上下文中模拟某些组件。例如，你可能在某个远程服务上有一个 facade，在开发期间该服务不可用。当你希望模拟在实际环境中可能难以触发的故障时，模拟也很有用。

Spring Boot 包含一个 @MockBean 注解，该注解可用于为应用上下文中的 bean 定义 Mockito 模拟。可以使用注解添加新 bean 或替换单个现有 bean 定义。注解可直接用于测试类、测试中的字段或 @Configuration 类和字段。在字段上使用时，也会注入创建的模拟的实例。mock bean 在每个测试方法后自动重置。

注释：

如果你的测试使用 Spring Boot 的测试注解之一（如 @SpringBootTest），则会自动启用此功能。要将此功能与其他安排一起使用，必须显式添加监听器，如下面示例所示：

```
@TestExecutionListeners(MockitoTestExecutionListener.class)
```

以下示例使用模拟（mock）实现替换现有的 RemoteService bean：

```
import org.junit.*;
import org.junit.runner.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.context.*;
import org.springframework.boot.test.mock.mockito.*;
import org.springframework.test.context.junit4.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.BDDMockito.*;

@RunWith(SpringRunner.class)
@SpringBootTest
public class MyTests {

    @MockBean
    private RemoteService remoteService;

    @Autowired
    private Reverser reverser;

    @Test
    public void exampleTest() {
        // RemoteService has been injected into the reverser bean
        given(this.remoteService.someCall()).willReturn("mock");
        String reverse = reverser.reverseSomeCall();
        assertThat(reverse).isEqualTo("kcom");
    }

}
```

注释：@MockBean 不能用于模拟在应用程序上下文刷新期间执行的 bean 的行为。执行测试时，应用程序上下文刷新已完成，配置模拟行为为时已晚。在这种情况下，我们建议使用 @Bean 方法来创建和配置模拟。

另外，你可以使用 @SpyBean 将任何现有的 bean 与 Mockito spy 打包在一起。有关详细信息，请参阅 [Javadoc](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/api/org/springframework/boot/test/mock/mockito/SpyBean.html)。

注释：虽然 Spring 的测试框架在测试之间缓存应用程序上下文，并为共享相同配置的测试重用上下文，但 @MockBean 或 @SpyBean 的使用会影响缓存键, 这很可能会增加上下文的数量。

提示：如果你使用 @SpyBean 来监视带有 @Cacheable 方法的 bean，该方法按名称引用参数，则你的应用程序必须使用 -parameters 进行编译。这确保参数名称在 bean 被监视后可用于缓存基础设施。

### 46.3.8、自动配置的测试

Spring Boot 的自动配置系统适用于应用程序，但有时对测试来说可能有点太多。这通常有助于只加载测试应用程序 “切片” 所需的配置部分。例如，你可能想要测试 Spring MVC 控制器是否正确映射 URLs，并且你不想在这些测试中涉及数据库调用，或者你可能想要测试 JPA 实体, 当这些测试运行时，你对 web 层不感兴趣。

spring-boot-test-autoconfigure 模块包含许多注解，可用于自动配置此类 “切片”。它们中的每一个都以类似的方式工作，提供一个加载 ApplicationContext 的 @…Test 注解和一个或多个可用于自定义自动配置设置的 @AutoConfigure… 注解。

注释：每个切片将组件扫描限制为适当的组件，并加载一组非常受限制的自动配置类。如果你需要排除其中一个，大多数 @…Test 注解都提供了一个 excludeAutoConfiguration 属性。或者，你可以使用 @ImportAutoConfiguration#exclude。

注释：不支持在一个测试中使用多个 @…Test 注解来包含多个 “切片”。如果你需要多个 “切片”，请选择其中一个 @…Test 注解，并手动包含其他 “切片” 的 @AutoConfigure… 注解。

提示：也可以将 @AutoConfigure… 注解与标准的 @SpringBootTest 注解一起使用。如果你对应用程序的“切片”不感兴趣，但需要一些自动配置的测试 bean，则可以使用此组合。

### 46.3.9、自动配置的 JSON 测试

要测试对象 JSON 序列化和反序列化是否按预期工作，可以使用 @JsonTest 注解。@JsonTest 自动配置可用的受支持 JSON 映射器，该映射器可以是以下库之一：

```
（1）Jackson ObjectMapper、任何 @JsonComponent bean 和任何 Jackson Module
（2）Gson
（3）Jsonb
```

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @JsonTest 启用的自动配置的列表。

如果需要配置自动配置的元素，可以使用 @AutoConfigureJsonTesters 注解。

Spring Boot 包括基于 AssertJ 的帮助器，它们与 JSONAssert 和 JsonPath 库一起工作，检查 JSON 是否如预期的那样出现。JacksonTester、GsonTester、JsonbTester 和 BasicJsonTester 类可以分别用于 Jackson、Gson、Jsonb 和 String。使用 @JsonTest 时，测试类上的任何帮助器字段都可以 @Autowired。以下示例展示了 Jackson 的测试类：

```
import org.junit.*;
import org.junit.runner.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.json.*;
import org.springframework.boot.test.context.*;
import org.springframework.boot.test.json.*;
import org.springframework.test.context.junit4.*;

import static org.assertj.core.api.Assertions.*;

@RunWith(SpringRunner.class)
@JsonTest
public class MyJsonTests {

    @Autowired
    private JacksonTester<VehicleDetails> json;

    @Test
    public void testSerialize() throws Exception {
        VehicleDetails details = new VehicleDetails("Honda", "Civic");
        // Assert against a `.json` file in the same package as the test
        assertThat(this.json.write(details)).isEqualToJson("expected.json");
        // Or use JSON path based assertions
        assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
        assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make")
                .isEqualTo("Honda");
    }

    @Test
    public void testDeserialize() throws Exception {
        String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
        assertThat(this.json.parse(content))
                .isEqualTo(new VehicleDetails("Ford", "Focus"));
        assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
    }

}
```

注释：JSON 帮助器类也可以直接用于标准单元测试。为此，如果不使用 @JsonTest，请在 @Before 方法中调用帮助器的 initFields 方法。

如果你使用 Spring Boot 的基于 AssertJ 的帮助器在给定的 JSON 路径上对数字值进行断言，则可能无法根据类型使用 isEqualTo。相反，你可以使用 AssertJ 的 satisfies 来断言值与给定条件匹配。例如，下面的示例断言实际的数字是一个接近 0.15 的浮点值，偏移量为 0.01。

```
assertThat(json.write(message))
    .extractingJsonPathNumberValue("@.test.numberValue")
    .satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
```

### 46.3.10、自动配置的 Spring MVC 测试

要测试 Spring MVC 控制器是否按预期工作，请使用 @WebMvcTest 注解。@WebMvcTest 自动配置 Spring MVC 基础设施，并将扫描的 bean 限制为 @Controller、@ControllerAdvice、@JsonComponent、Converter、GenericConverter、Filter、WebMVCConfiguer 和 HandlerMethodArgumentResolver。使用此注解时，不扫描常规 @Component bean。

提示：可以在[附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @WebMvcTest 启用的自动配置设置的列表。

提示：如果你需要注册额外的组件，比如 Jackson Module，你可以在测试中使用 @Import 来导入额外的配置类。

通常，@WebMvcTest 仅限于单个控制器，并与 @MockBean 结合使用，为所需的协作者提供模拟实现。

@WebMvcTest 也会自动配置 MockMvc。Mock MVC 提供了一种强大的方法来快速测试 MVC 控制器，而不需要启动完整的 HTTP 服务器。

提示：你还可以在非 @WebMvcTest（如 @SpringBootTest）中自动配置 MockMvc，方法是使用 @AutoConfigureMockMvc 对其进行注解。以下示例使用 MockMvc：

```
import org.junit.*;
import org.junit.runner.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.web.servlet.*;
import org.springframework.boot.test.mock.mockito.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.BDDMockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringRunner.class)
@WebMvcTest(UserVehicleController.class)
public class MyControllerTests {

    @Autowired
    private MockMvc mvc;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    public void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
    }

}
```

提示：如果你需要配置自动配置的元素（例如，当应用 servlet 过滤器时），你可以使用 @AutoConfigureMockMvc 注解中的属性。

如果使用 HtmlUnit 或 Selenium，自动配置还提供了一个 HTMLUnit WebClient bean 和/或一个 WebDriver bean。以下示例使用 HtmlUnit：

```
import com.gargoylesoftware.htmlunit.*;
import org.junit.*;
import org.junit.runner.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.web.servlet.*;
import org.springframework.boot.test.mock.mockito.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.BDDMockito.*;

@RunWith(SpringRunner.class)
@WebMvcTest(UserVehicleController.class)
public class MyHtmlUnitTests {

    @Autowired
    private WebClient webClient;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    public void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
        assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
    }

}
```

注释：默认情况下，Spring Boot 将 WebDriver bean 放在一个特殊的“scope”中，以确保驱动程序在每次测试后退出，并注入新实例。如果你不想要这种行为，你可以将 @Scope("singleton") 添加到你的 WebDriver @Bean 定义中。

警告：Spring Boot 创建的 webDriver 范围将替换任何同名的用户定义范围。如果你定义自己的 webDriver 范围，你可能会发现在使用 @WebMvcTest 时它停止工作。

如果类路径上有Spring Security，@WebMvcTest 也将扫描 WebSecurityConfigurer bean。你可以使用 Spring Security 的测试支持，而不是完全禁用此类测试的安全性。有关如何使用 Spring Security 的 MockMvc 支持的更多详细信息，请参见[第 80 章：使用 Spring Security 进行测试的操作指南部分](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/howto-use-test-with-spring-security.html)。

提示：有时编写 Spring MVC 测试是不够的；Spring Boot 可以帮助你[在实际的服务器上运行完整的端到端测试](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server)。

### 46.3.11、自动配置的 Spring WebFlux 测试

要测试 Spring WebFlux 控制器是否按预期工作，可以使用 @WebFluxTest 注解。@WebFluxTest 自动配置 Spring WebFlux 基础设施，并将扫描的 bean 限制为 @Controller 、 @ControllerAdvice 、 @JsonComponent 、 Converter 、 GenericConverter 和 WebFluxConfigurer。当使用 @WebFluxTest 注解时，不会扫描常规 @Component bean。

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @WebFluxTest 启用的自动配置的列表。

提示：如果你需要注册额外的组件，比如 Jackson Module，你可以在测试中使用 @Import 来导入额外的配置类。

通常，@WebFluxTest 仅限于单个控制器，并与 @MockBean 结合使用，为所需的协作者提供模拟实现。

@WebFluxTest 也会自动配置 WebTestClient。它提供了一种强大的方法来快速测试 WebFlux 控制器，而不需要启动完整的 HTTP 服务器。

提示：你还可以在非 @WebFluxTest（如 @SpringBootTest）中自动配置 WebTestClient，方法是使用 @AutoConfigureWebTestClient 对其进行注解。以下示例展示一个同时使用 @WebFluxTest 和 WebTestClient 的类：

```
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.reactive.server.WebTestClient;

@RunWith(SpringRunner.class)
@WebFluxTest(UserVehicleController.class)
public class MyControllerTests {

    @Autowired
    private WebTestClient webClient;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    public void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("Honda Civic");
    }

}
```

提示：此设置仅被 WebFlux 应用程序支持，因为在模拟的 web 应用程序中使用 WebTestClient 目前仅适用于 WebFlux。

注释：@WebFluxTest 无法检测通过功能性 web 框架注册的路由。为了在上下文中测试 RouterFunction bean，请考虑通过 @Import 或使用 @SpringBootTest 自己导入 RouterFunction。

注释：@WebFluxTest 无法检测通过 SecurityWebFilterChain 类型的 @Bean 注册的自定义安全配置。要在测试中包含它，你需要通过 @Import 或使用 @SpringBootTest 导入注册 bean 的配置。

提示：有时编写 Spring WebFlux 测试是不够的；Spring Boot 可以帮助你[在实际的服务器上运行完整的端到端测试](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server)。

## 46.3.12、自动配置的 Data JPA 测试

你可以使用 @DataJpaTest 注解来测试 JPA 应用程序。默认情况下，它扫描 @Entity 类并配置 Spring Data JPA 存储库。如果类路径上有可用的嵌入式数据库，它也会配置一个。常规 @Component bean 未加载到 ApplicationContext 中。

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @DataJpaTest 启用的自动配置的列表。

默认情况下，Data JPA 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见 Spring Framework 参考文档中的相关部分。如果这不是你想要的，你可以为一个测试或整个类禁用事务管理，如下所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@RunWith(SpringRunner.class)
@DataJpaTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class ExampleNonTransactionalTests {

}
```

Data JPA 测试也可以注入 TestEntityManager bean，它提供了一个替代专门为测试设计的标准 JPA EntityManager 的方法。如果要在 @DataJpaTest 实例之外使用 TestEntityManager，也可以使用 @AutoConfigureTestEntityManager 注解。如果需要，也可以使用 JdbcTemplate。以下示例显示了正在使用的 @DataJpaTest 注解：

```
import org.junit.*;
import org.junit.runner.*;
import org.springframework.boot.test.autoconfigure.orm.jpa.*;

import static org.assertj.core.api.Assertions.*;

@RunWith(SpringRunner.class)
@DataJpaTest
public class ExampleRepositoryTests {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private UserRepository repository;

    @Test
    public void testExample() throws Exception {
        this.entityManager.persist(new User("sboot", "1234"));
        User user = this.repository.findByUsername("sboot");
        assertThat(user.getUsername()).isEqualTo("sboot");
        assertThat(user.getVin()).isEqualTo("1234");
    }

}
```

内存中的嵌入式数据库通常可以很好地用于测试，因为它们速度快，不需要任何安装。但是，如果希望对真实数据库运行测试，则可以使用 @AutoConfigureTestDatabase 注解，如下面示例所示：

```
@RunWith(SpringRunner.class)
@DataJpaTest
@AutoConfigureTestDatabase(replace=Replace.NONE)
public class ExampleRepositoryTests {

    // ...

}
```

### 46.3.13、自动配置的 JDBC 测试

@JdbcTest 类似于 @DataJpaTest，但只用于只需要 DataSource 而不使用 Spring Data JDBC 的测试。默认情况下，它配置内存中的嵌入式数据库和 JdbcTemplate。常规 @Component bean 未加载到 ApplicationContext 中。

提示：可以在附录中找到由 @JdbcTest 启用的自动配置的列表。

默认情况下，JDBC 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见 Spring Framework 参考文档中的相关部分。如果这不是你想要的，你可以为一个测试或整个类禁用事务管理，如下所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@RunWith(SpringRunner.class)
@JdbcTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class ExampleNonTransactionalTests {

}
```

如果希望你的测试在真实的数据库上运行，你可以使用 @AutoConfigureTestDatabase 注解，其方式与 DataJpaTest 相同。（请参见[第 46.3.12 节：自动配置的 Data JPA 测试](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test)）

### 46.3.14、自动配置的 Data JDBC 测试

@DataJdbcTest 类似于 @JdbcTest，但用于使用 Spring Data JDBC 存储库的测试。默认情况下，它配置内存中的嵌入式数据库、JdbcTemplate 和 Spring Data JDBC 存储库。常规 @Component bean 未加载到 ApplicationContext 中。

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @DataJdbcTest 启用的自动配置的列表。

默认情况下，Data JDBC 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见 Spring Framework 参考文档中的相关部分。如果这不是你想要的，你可以为一个测试或整个测试类禁用事务管理，如 [JDBC 示例所示](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test)。

如果希望你的测试在真实的数据库上运行，你可以使用 @AutoConfigureTestDatabase 注解，其方式与 DataJpaTest 相同。（请参见[第 46.3.12节：自动配置的 Data JPA 测试](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test)）

### 46.3.15、自动配置的 jOOQ 测试

你可以以与 @JdbcTest 类似的方式使用 @JooqTest，但用于 jOOQ 相关的测试。由于 jOOQ 严重依赖与数据库模式相对应的基于 Java 的模式，因此使用了现有的数据源。如果要将其替换为内存数据库，可以使用 @AutoConfigureTestDatabase 覆盖这些设置。（有关在 Spring Boot 中使用 jOOQ 的更多信息，请参阅本章之前的[第 31.6 节：使用 jOOQ](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-sql.html#boot-features-jooq)。）常规 @Component bean 未加载到 ApplicationContext 中。

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @JooqTest 启用的自动配置的列表。

@JooqTest 配置 DSLContext。常规 @Component bean 未加载到 ApplicationContext 中。以下示例显示了正在使用的 @JooqTest 注解：

```
import org.jooq.DSLContext;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.autoconfigure.jooq.JooqTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@JooqTest
public class ExampleJooqTests {

    @Autowired
    private DSLContext dslContext;
}
```

默认情况下，JOOQ 测试是事务性的，并在每个测试结束时回滚。如果这不是你想要的，你可以为一个测试或整个测试类禁用事务管理，如 [JDBC 示例所示](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test)。

### 46.3.16、自动配置的 Data MongoDB 测试

你可以使用 @DataMongoTest 测试 MongoDB 应用程序。默认情况下，它配置内存中嵌入的 MongoDB（如果可用），配置 MongoTemplate，扫描 @Document 类，并配置 Spring Data MongoDB 存储库。常规 @Component bean 未加载到 ApplicationContext 中。（有关在 Spring Boot 中使用 MongoDB 的更多信息，请参阅本章之前的[第 32.2 节：MongoDB](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-nosql.html#boot-features-mongodb)。）

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @DataMongoTest 启用的自动配置的列表。

以下类显示了正在使用的 @DataMongoTest 注解：

```
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@DataMongoTest
public class ExampleDataMongoTests {

    @Autowired
    private MongoTemplate mongoTemplate;

    //
}
```

内存中嵌入的 MongoDB 通常可以很好地用于测试，因为它速度快，不需要任何开发者安装。但是，如果你希望对真实的 MongoDB 服务器运行测试，则应排除嵌入式 MongoDB 的自动配置，如下面示例所示：

```
import org.junit.runner.RunWith;
 import org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)
public class ExampleDataMongoNonEmbeddedTests {

}
```

### 46.3.17、自动配置的 Data Neo4j 测试

你可以使用 @DataNeo4jTest 测试 Neo4j 应用程序。默认情况下，它使用内存中嵌入的 Neo4j（如果嵌入式驱动程序可用），扫描 @NodeEntity 类，并配置 Spring Data Neo4j 存储库。常规 @Component bean 未加载到 ApplicationContext 中。（有关在 Spring Boot 中使用 Neo4J 的更多信息，请参见本章之前的[第 32.3 节：Neo4j](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-nosql.html#boot-features-neo4j)）。

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @DataNeo4jTest 启用的自动配置的列表。

以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置：

```
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@DataNeo4jTest
public class ExampleDataNeo4jTests {

    @Autowired
    private YourRepository repository;

    //
}
```

默认情况下，Data Neo4j 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见 Spring Framework 参考文档中的相关部分。如果这不是你想要的，你可以为一个测试或整个类禁用事务管理，如下所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@RunWith(SpringRunner.class)
@DataNeo4jTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public class ExampleNonTransactionalTests {

}
```

### 46.3.18、自动配置的 Data Redis 测试

你可以使用 @DataRedisTest 测试 Redis 应用程序。默认情况下，它会扫描 @RedisHash 类并配置 Spring Data Redis 存储库。常规 @Component bean 未加载到 ApplicationContext 中。(有关在 Spring Boot 中使用 Redis 的更多信息，请参阅本章之前的[第 32.1 节：Redis](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-nosql.html#boot-features-redis)。)

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @DataRedisTest 启用的自动配置的列表。

以下示例展示了正在使用的 @DataRedisTest 注解：

```
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@DataRedisTest
public class ExampleDataRedisTests {

    @Autowired
    private YourRepository repository;

    //
}
```

### 46.3.19、自动配置的 Data LDAP 测试

你可以使用 @DataLdapTest 测试 LDAP 应用程序。默认情况下，它配置内存中嵌入的 LDAP（如果可用），配置 LdapTemplate，扫描 @Entry 类，并配置 Spring Data LDAP 存储库。常规 @Component bean 未加载到 ApplicationContext 中。(有关在 Spring Boot 中使用 LDAP 的更多信息，请参阅本章之前的[第 32.9 节：LDAP](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-nosql.html#boot-features-ldap)。)

可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @DataLdapTest 启用的自动配置的列表。

以下示例展示了正在使用的 @DataLdapTest 注解：

```
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
import org.springframework.ldap.core.LdapTemplate;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@DataLdapTest
public class ExampleDataLdapTests {

    @Autowired
    private LdapTemplate ldapTemplate;

    //
}
```

内存中嵌入的 LDAP 通常可以很好地用于测试，因为它速度快，不需要任何开发者安装。但是，如果你希望对真实的 LDAP 服务器运行测试，则应排除嵌入式 LDAP 的自动配置，如下面示例所示：

```
import org.junit.runner.RunWith;
import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
public class ExampleDataLdapNonEmbeddedTests {

}
```

### 46.3.20、自动配置的 REST 客户端

你可以使用 @RestClientTest 注解来测试 REST 客户端。默认情况下，它会自动配置 Jackson、 GSON 和 Jsonb 支持，配置 RestTemplateBuilder，并添加对 MockRestServiceServer 的支持。常规 @Component bean 未加载到 ApplicationContext 中。

提示：可以[在附录中找到](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/test-auto-configuration.html)由 @RestClientTest 启用的自动配置的列表。

要测试的特定 bean 应使用 @RestClientTest 的 value 或 components 属性指定，如下面示例所示：

```
@RunWith(SpringRunner.class)
@RestClientTest(RemoteVehicleDetailsService.class)
public class ExampleRestClientTest {

    @Autowired
    private RemoteVehicleDetailsService service;

    @Autowired
    private MockRestServiceServer server;

    @Test
    public void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails()
            throws Exception {
        this.server.expect(requestTo("/greet/details"))
                .andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
        String greeting = this.service.callRestService();
        assertThat(greeting).isEqualTo("hello");
    }

}
```

### 46.3.21、自动配置的 Spring REST Docs 测试

你可以使用 @AutoConfigureRestDocs 注解来在带有 Mock MVC、REST Assured 或 WebTestClient 的测试中使用 Spring REST Docs。它消除了 [Spring REST Docs](https://projects.spring.io/spring-restdocs/) 中对 JUnit 规则的需要。

@AutoConfigureRestDocs 可用于覆盖默认输出目录 (如果使用 Maven，则为 target/generated-snippets，如果使用 Gradle，则为 build/generated-snippets)。它还可用于配置出现在任何记录的 URIs 中的主机、模式（scheme）和端口。

**用 Mock MVC 的自动配置的 Spring REST Docs 测试**

@AutoConfigureRestDocs 自定义 MockMvc bean 以使用 Spring REST Docs。你可以使用 @Autowired 注入它，并在测试中使用它，就像使用 Mock MVC 和 Spring REST Docs 时一样，如下面示例所示：

```
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringRunner.class)
@WebMvcTest(UserController.class)
@AutoConfigureRestDocs
public class UserDocumentationTests {

    @Autowired
    private MockMvc mvc;

    @Test
    public void listUsers() throws Exception {
        this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk())
                .andDo(document("list-users"));
    }

}
```

如果你需要对 Spring REST Docs 配置的更多控制，而不是由 @AutoConfigureRestDocs 的属性提供，则你可以使用 RestDocsMockMvcConfigurationCustomizer bean，如下面示例所示：

```
@TestConfiguration
static class CustomizationConfiguration
        implements RestDocsMockMvcConfigurationCustomizer {

    @Override
    public void customize(MockMvcRestDocumentationConfigurer configurer) {
        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
    }

}
```

如果你想利用 Spring REST Docs 对参数化输出目录的支持，可以创建 RestDocumentationResultHandler bean。自动配置使用此结果处理器调用 alwaysDo，从而使每个 MockMvc 调用自动生成默认代码片段。下面的示例展示了定义的RestDocumentationResultHandler：

```
@TestConfiguration
static class ResultHandlerConfiguration {

    @Bean
    public RestDocumentationResultHandler restDocumentation() {
        return MockMvcRestDocumentation.document("{method-name}");
    }

}
```

**用 WebTestClient 的自动配置的 Spring REST Docs 测试**

@AutoConfigureRestDocs 也可以与 WebTestClient 一起使用。你可以使用 @Autowired 注入它，并在测试中使用它，就像使用 @WebFluxTest 和 Spring REST Docs 时一样，如下面示例所示：

```
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.reactive.server.WebTestClient;

import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document;

@RunWith(SpringRunner.class)
@WebFluxTest
@AutoConfigureRestDocs
public class UsersDocumentationTests {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    void listUsers() {
        this.webTestClient.get().uri("/").exchange().expectStatus().isOk().expectBody()
                .consumeWith(document("list-users"));
    }

}
```

如果你需要对 Spring REST Docs 配置的更多控制，而不是由 @AutoConfigureRestDocs 的属性提供，则你可以使用 RestDocsWebTestClientConfigurationCustomizer bean，如下面示例所示：

```
@TestConfiguration
public static class CustomizationConfiguration implements RestDocsWebTestClientConfigurationCustomizer {

    @Override
    public void customize(WebTestClientRestDocumentationConfigurer configurer) {
        configurer.snippets().withEncoding("UTF-8");
    }

}
```

**用 REST Assured 的自动配置的 Spring REST Docs 测试**

@AutoConfigureRestDocs 使预先配置为使用 Spring REST Docs 的 RequestSpecification bean 可用于你的测试。你可以使用 @Autowired 注入它，并在测试中使用它，就像使用 REST Assured 和 Spring REST Docs 时一样，如下面示例所示：

```
import io.restassured.specification.RequestSpecification;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.test.context.junit4.SpringRunner;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;
import static org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureRestDocs
public class UserDocumentationTests {

    @LocalServerPort
    private int port;

    @Autowired
    private RequestSpecification documentationSpec;

    @Test
    public void listUsers() {
        given(this.documentationSpec).filter(document("list-users")).when().port(this.port).get("/").then().assertThat()
                .statusCode(is(200));
    }

}
```

如果你需要对 Spring REST Docs 配置的更多控制，而不是由 @AutoConfigureRestDocs 的属性提供，则你可以使用 RestDocsRestAssuredConfigurationCustomizer bean，如下面示例所示：

```
@TestConfiguration
public static class CustomizationConfiguration implements RestDocsRestAssuredConfigurationCustomizer {

    @Override
    public void customize(RestAssuredRestDocumentationConfigurer configurer) {
        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
    }

}
```

### 46.3.22、附加的自动配置和切片

每个切片提供一个或多个 @AutoConfigure… 注解，即定义应该作为切片一部分被包含的自动配置。可以通过创建自定义的 @AutoConfigure… 注解或简单地向测试添加 @ImportAutoConfiguration 来添加其他自动配置，如下例所示：

```
@RunWith(SpringRunner.class)
@JdbcTest
@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
public class ExampleJdbcTests {

}
```

注释：确保不要使用常规的 @Import 注解来导入自动配置，因为它们是由 Spring Boot 以特定方式处理的。

### 46.3.23、用户配置和切片

如果你以一种合理的方式构造代码，那么你的 @SpringBootApplication 类将被默认用作测试的配置。

然后，不要将应用程序的主类与特定于其功能的特定区域的配置设置混杂在一起，这一点变得非常重要。

假设你正在使用 Spring Batch，并且依赖于它的自动配置。你可以像下面这样定义 @SpringBootApplication：

```
@SpringBootApplication
@EnableBatchProcessing
public class SampleApplication { ... }
```

因为这个类是测试的源配置，任何切片测试实际上都试图启动 Spring Batch，这绝对不是你想要做的。建议的方法是将特定于区域的配置移动到与应用程序处于同一级别的单独 @Configuration 类中，如下面示例所示：

```
@Configuration
@EnableBatchProcessing
public class BatchConfiguration { ... }
```

注释：根据应用程序的复杂性，你可以为自定义设置使用单个 @Configuration 类，也可以为每个域区域使用一个类。后一种方法允许你在一个测试中启用它，如果需要，可以使用 @Import 注解。

测试切片从扫描中排除 @Configuration 类。例如，对于 @WebMvcTest，以下配置不会在测试切片加载的应用程序上下文中包含给定的 WebMvcConfigurer bean：

```
@Configuration
public class WebConfiguration {
    @Bean
    public WebMvcConfigurer testConfigurer() {
        return new WebMvcConfigurer() {
            ...
        };
    }
}
```

但是，下面的配置将导致测试切片加载自定义 WebMvcConfigurer。

```
@Component
public class TestWebMvcConfigurer extends WebMvcConfigurer {
    ...
}
```

混淆的另一个来源是类路径扫描。假设，当你以合理的方式构建代码时，你需要扫描一个额外的包。你的应用程序可能类似于以下代码:

```
@SpringBootApplication
@ComponentScan({ "com.example.app", "org.acme.another" })
public class SampleApplication { ... }
```

这样做有效地覆盖了默认的组件扫描指令，其副作用是扫描这两个包，而不考虑你选择的切片。例如，@DataJpaTest 似乎突然扫描应用程序的组件和用户配置。同样，将自定义指令移动到单独的类是解决此问题的好方法。

提示：如果这不是你的选项，你可以在测试层次结构中的某个位置创建 @SpringBootConfiguration，以便使用它。或者，可以为测试指定一个源，这将禁用查找默认源的行为。

### 46.3.24、使用 Spock 测试 Spring Boot 应用程序

如果你希望使用 Spock 测试 Spring Boot 应用程序，则应在应用程序的构建中添加对 Spock 的 spock-spring 模块的依赖。spock-spring 将 Spring 的测试框架集成到 Spock 中。建议你使用 Spock 1.2 或更高版本，以受益于对 Spock 的 Spring Framework 和 Spring Boot 集成的许多改进。有关更多详细信息，请参阅 [Spock 的 Spring 模块的文档](http://spockframework.org/spock/docs/1.2/modules.html#_spring_module)。

## 46.4、测试工具

测试应用程序时通常有用的一些测试工具类被打包为 spring-boot 的一部分。

### 46.4.1、ConfigFileApplicationContextInitializer

ConfigFileApplicationContextInitializer 是一个 ApplicationContextInitializer，你可以将其应用于测试以加载 Spring Boot application.properties 文件。当不需要 @SpringBootTest 提供的全套功能时，可以使用它，如下例所示：

```
@ContextConfiguration(classes = Config.class,
    initializers = ConfigFileApplicationContextInitializer.class)
```

注释：单独使用 ConfigFileApplicationContextInitializer 不支持 @Value（${…}）注入。它的唯一工作是确保 application.properties 文件加载到 Spring 的 Environment 中。对于 @Value 支持，你需要另外配置 PropertySourcesPlaceholderConfigurer 或使用 @SpringBootTest，后者会自动为你配置一个。

### 46.4.2、TestPropertyValues

TestPropertyValues 允许你快速向 ConfigurableEnvironment 或 ConfigurableApplicationContext 添加属性。你可以使用 key=value 字符串调用它，如下所示：

```
TestPropertyValues.of("org=Spring", "name=Boot").applyTo(env);
```

### 46.4.3、OutputCapture

OutputCapture 是一个 JUnit 规则，可用于捕获 System.out 和 System.err 输出。你可以将捕获声明为 @Rule，然后对断言使用 toString()，如下所示：

```
import org.junit.Rule;
import org.junit.Test;
import org.springframework.boot.test.rule.OutputCapture;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;

public class MyTest {

    @Rule
    public OutputCapture capture = new OutputCapture();

    @Test
    public void testName() throws Exception {
        System.out.println("Hello World!");
        assertThat(capture.toString(), containsString("World"));
    }

}
```

### 46.4.4、TestRestTemplate

提示：Spring Framework 5.0 提供了一个新的 WebTestClient，它适用于 WebFlux 集成测试以及 WebFlux 和 MVC 端到端测试。与 TestRestTemplate 不同，它为断言提供了一个流畅的 API。

TestRestTemplate 是 Spring RestTemplate 的一个方便的替代方案，后者在集成测试中很有用。你可以获得一个普通模板或发送 Basic HTTP 身份验证的模板 (带有用户名和密码)。在任何一种情况下，模板都以测试友好的方式运行，不引发服务器端错误的异常。建议使用 Apache HTTP Client (版本 4.3.2 或更高版本)，但不是强制性的。如果你的类路径上有该模板，则 TestRestTemplate 通过适当配置客户端来响应。如果您确实使用 Apache 的 HTTP 客户端，则会启用一些其他的测试友好型功能：

```
（1）不遵循重定向（因此你可以断言响应位置）。
（2）Cookies 被忽略（因此模板是无状态的）。
```

可以在集成测试中直接实例化 TestRestTemplate，如下面示例所示:

```
public class MyTest {

    private TestRestTemplate template = new TestRestTemplate();

    @Test
    public void testRequest() throws Exception {
        HttpHeaders headers = this.template.getForEntity(
                "https://myhost.example.com/example", String.class).getHeaders();
        assertThat(headers.getLocation()).hasHost("other.example.com");
    }

}
```

或者，如果将 @SpringBootTest 注解与 WebEnvironment.RANDOM_PORT 或 WebEnvironment.DEFINED_PORT 一起使用，则可以注入完全配置的 TestRestTemplate 并开始使用它。如有必要，可以通过 RestTemplateBuilder bean 应用其他自定义。任何未指定主机和端口的 URL 都会自动连接到嵌入式服务器，如下面示例所示：

```
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class SampleWebClientTests {

    @Autowired
    private TestRestTemplate template;

    @Test
    public void testRequest() {
        HttpHeaders headers = this.template.getForEntity("/example", String.class).getHeaders();
        assertThat(headers.getLocation()).hasHost("other.example.com");
    }

    @TestConfiguration
    static class Config {

        @Bean
        public RestTemplateBuilder restTemplateBuilder() {
            return new RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1))
                    .setReadTimeout(Duration.ofSeconds(1));
        }

    }

}
```
